---
title: Abordagens composicionais
---

Neste capítulo discutiremos uma das mais interessantes e promissoras ramificações do Projeto MPB: a composição assistida. Em termos bem sucintos, compor dentro sistema se dá através uma lógica em "engenharia reversa", ou seja, tomando como base dados estatísticos compilados do processo de análise dos *corpora*. Importante frisar que não se trata de *composição algorítmica* (pelo menos em seu sentido mais conhecido), ou seja, um processo automatizado (ou semiautomatizado). Na verdade, poderíamos pensar que o sistema atuaria -- em estágios específicos do processo composicional -- apenas como um *fornecedor* de um espectro alternativas estatisticamente embasadas em relações a aspectos estruturais previamente mapeados (associados a alturas, ritmo e/ou harmonia) nas análises dos *corpora*. Assim, o(a) compositor(a) mantém sempre suas prerrogativas para tomar decisões e fazer o que entende como as melhores escolhas dentre as opções disponíveis a cada momento, conectando-las de modo lógico e criativo a uma estrutura imaginada para sua obra (o que não deixa de ser uma possível definição para o ato de compor).

Em outros termos, a composição dentro desse sistema não é, de modo algum, regida pelo determinismo, já que encontra a cada etapa uma considerável margem de flexibilidade. Isso pode ser constatado nos três principais eixos musicais alimentados pelos dados analíticos, a saber, harmonia, melodia e ritmo, como se segue: 

**Flexibilidade harmônica** -- as sequências de acordes geradas pelo algoritmo-compositor específico (ver mais à frente) são desvinculadas de quaisquer referências a posições métricas e durações. 

**Flexibilidade melódica** -- as sequências de c-letras, ou seja, as *c-palavras* geradas pelo algoritmo-compositor específico (ver mais à frente) indicam apenas "gestos de contorno" básicos, que podem ser realizados de modos consideravelmente distintos.

**Flexibilidade rítmica** -- as sequências de r-letras, ou seja, as *r-palavras* geradas pelo algoritmo-compositor específico (ver mais à frente) são "agnósticas" em relação à métrica, o que significa que devem ser consideradas como unidades autônomas que podem ser posicionadas metricamente a critério do(a) compositor(a). Isso inclui também a liberdade de poder distanciar livremente unidades contíguas. 

---

### ALGORITMOS-COMPOSITORES
Em sua versão atual, o processo composicional dentro do sistema é baseado em três algoritmos-compositores, cada qual associado a um domínio estrutural-musical, a saber, harmonia, ritmo e alturas. Os três algoritmos são alimentados por dados estatísticos referentes a transições entre eventos contíguos, registrados nas *matrizes de transição probabilística* (ver capítulo sobre processos markovianos) dos 10 *corpora* analisados. De um modo geral, os algoritmos operam da seguinte maneira: o usuário informa o *corpus* de referência, o evento-semente (que, dependendo do domínio selecionado, pode ser uma categoria funcional, uma r-letra ou uma c-letra) e o número de iterações desejado. O algoritmo então retorna uma estrutura completa (uma sequência de acordes, uma r-palavra ou uma c-palavra) que guarda -- ao menos em termos probabilísticos -- estreitos vínculos com o *corpus* selecionado.

(1) *corporaKov2.py* -- código implementado em linguagem Python, recebe como *input* informações sobre o *corpus* considerado, o "acorde-semente" (uma categoria funcional a partir da qual o usuário pretende construir uma sequência harmônica) e o número de iterações desejado (ou seja, a extensão da sequência). O algoritmo retorna a sequência em três versões: (a) em categorias funcionais; (b) em cifras alfanuméricas e (c) em notação genealógica (ver glossário), como tipos acordais registrados no modelo GTA (ver capítulo sobre os modelos teóricos adotados no projeto). A [@fig-comp01] apresenta o fluxograma referente ao algoritmo e um exemplo de sua aplicação.

![Esquema básico do algoritmo *corparoKov2.py* e um exemplo.](../figs/composição-01.png){width=75% #fig-comp01}

(2) *corporaKov_ritmo.py* --  código implementado em linguagem Python, recebe como *input* informações sobre o *corpus* considerado, a "r-letra-semente" (uma r-letra a partir da qual o usuário pretende construir r-palavra) e o número de iterações desejado (ou seja, a extensão da sequência em número de r-letras). O algoritmo retorna como *output* uma r-palavra original (e probabilisticamente vinculada ao *corpus* em questão), juntamente com sua *cardinalidade* # (neste caso, o número total de ataques da r-palavra). A [@fig-comp02] apresenta o fluxograma referente ao algoritmo e um exemplo de sua aplicação.

([@fig-comp02]).

![Esquema básico do algoritmo *corparoKov_ritmo.py* e um exemplo.](../figs/composição-02.png){width=60% #fig-comp02}

(3) *corporaKov_contorno.py* -- código implementado em linguagem Python, recebe como *input* informações sobre o *corpus* considerado, a "c-letra-semente" (uma c-letra a partir da qual o usuário pretende construir c-palavra) e cardinalidade (que deverá coerente à cardinalidade de uma r-palavra correspondente, previamente construída). A [@fig-comp03] apresenta o fluxograma referente ao algoritmo e um exemplo de sua aplicação.


![Esquema básico do algoritmo *corparoKov_contorno.py* e um exemplo.](../figs/composição-03.png){width=60% #fig-comp03}

---

### ESTRATÉGIAS COMPOSICIONAIS
Até o presente momento, duas estratégias composicionais dentro do sistema foram idealizadas. Cada qual tem suas características, o que implica ..............

(1) 

(2)
